## 分析锁问题
使用mysqldumpslow检索慢查询的等待锁的时间（Lock）、扫描的行数（Rows）、执行查询的时间(Time)，例如执行如下命令
```code
./mysqldumpslow -t 1 -g ""select *"" /usr/local/mysql/data/s380-slow.log
```
得到结果:
```code
Count: 1  Time=3.88s (3s)  Lock=2.50s (0s)  Rows=100.0 (155494), root[root]@[172.17.**.**]
  SELECT * FROM `contract`.`contract_detail`
```	
分析是由其他业务影响，还是自身SQL的问题， 比如期望查询的时间是3秒，但是Lock的时间已经占用了2.5秒，这个时候应该去分析锁冲突的原因，而不是自身SQL的问题
## 分析I/O问题
1. 是否向数据库请求了不需要的数据，查询的字段、筛选的数据是否可以减少,减少查询字段更容易覆盖索引，缩小数据范围，减少查询出的数据量能占用更少的磁盘和内存
2. 如TEXT类型或较大的varchar字段，如不频繁访问该字段数据，可以拆分到其他表，拆分大字段可提高每个数据页可存储的数据量，降低物理I/O，
3. 只为了得到一个小字段，但是去join了一张或多张大表	是否可以冗余数据，采取空间换时间的做法。  

## 分析索引问题
1.	使用explain关键字查看执行计划的extra字段，如果order by 的条件不在索引列上，就会产生using filesort，尽量在索引列上完成排序,使用索引排序，尽量让查询出来的数据已经是排好序的
2. 不在sql中使用表达式计算，可以在业务中完成	确认不会因为表达式计算导致索引列失效
3. 使用区分度不高的索引导致仍然筛选出了大量的数据需要回表 
4. 可以覆盖索引，但是仍然查询了多余的字段
5. 确认查询条件无强制类型转换,如SELECT * FROM t WHERE id = ’19’，强制类型转换会导致索引失效
6. 如果该字段唯一，使用唯一索引而不是普通的二级索引，普通索引会扫描完整个索引文件，而唯一索引一次就可以确定结果
7. mysql会在union查询的时候给临时表加上distinct的关键字，这个操作的代价很高，同时会导致一些优化策略失效，如果可以接受重复数据，使用union all	
8. 确认join查询的关联字段是否使用索引、数据类型是否一致,join的关联字段如果建立了索引，可以减少join过程中的比较，加速查询,如果关联字段建立了索引，但是数据类型不一致，也会导致索引失效
9. 如果查询包含GROUP BY，但希望避免对结果进行排序的开销，则可以通过指定ORDER BY NULL来避免排序	确认group by是否需要排序，分组后如果不处理，会自动对分组的信息进行order by排序
		
		
		
		
		
		
