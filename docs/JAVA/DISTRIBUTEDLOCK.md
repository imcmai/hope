- #### 锁的概念:
	- 线程的通信方式有两种，同步和可见性
	- 同步的本质是通过锁来实现，可见性只在特定情况下才能保证线程安全，比如volitile，对jvm优化过后的指令进行重排序，强制要求线程刷新主存，但是 如果当前值由该变量以前的值相关 比如执行非原子操作的++，那这时候就不安全了
	- 比如java中大量用到的synchronized 锁，同时满足同步和可见性
	这是在单机系统中，但是在分布式系统中，多个相同服务就不能达到同步了
***
- #### 分布式锁的实现
    - 其实这个东西说起来也很简单，就是微服务的时代下应运而生的东西，实现方式主要为借助中间件 比如redis, memcached ,zookeeper等，有了这些中间件，分布式服务都会通过中间件去拿取和销毁锁，这样来完成同步

- #### memcached的实现:
    - client客户端用的是memcached-java-client
    - 会去memcached中插入一个k v ，k如果存在返回失败，否则返回true，比如应用于回绝重复请求，请求id可以作为key，设置time的过期时间是为了避免客户端宕机后造成死锁，另外memcached宕机的话，数据是不会恢复的，没有持久化功能，需要注意，集群一定程度上可以避免这个问题
```java
memCachedClient.add(key, value, time);
```
- #### Redis的实现
    - 借助到setnx关键字同样也是，存入kv，设置成功则表示加锁成功，为了避免死锁，还需要加上过期时间，早期redis的setnx和expire并不是原子性的，所以也会造成诸多问题，高版本已解决，另外如果key过期，业务逻辑还未执行完，导致释放掉锁也会产生问题，可以参考redisson的看门狗机制，启动一个线程定期去追加过期时间
### 补充
普通锁还是分布式锁取决于是否全局唯一 并不是什么高深莫测的东西
### springboot集成redisson实现分布式锁(redis集群为哨兵模式)
👉[springboot集成redisson实现分布式锁](/JAVA/redisson1.md)

