## 背景
参考资料[java并发编程实战](https://time.geekbang.org/column/article/85702)
### 随着CPU，内存，I/O设备迭代，三者之间速度具有巨大差异，为了平衡三者速度差异，利用cpu的高性能
    - cpu增加了缓存，均衡与内存的速度差异
    - 操作系统增加了进程，线程，以达到分时复用cpu，均衡cpu与I/O设备的速度差异
    - 编译程序优化指令执行次序，使得缓存能更好被利用
所以，并发编程bug的源头，都是因为这些而产生
## 问题
### 可见性
单核cpu所有线程都在一个cpu执行，所有线程写的都是同一个cpu缓存，所以这时是可以保持可见性的，但是在多核，不同线程有可能在不同的cpu缓存进行写操作，就会出现可见性问题，因为并不是直接从内存中读取数据，而是先写进cpu缓存，然后刷新内存值。
### 原子性
为了更好的利用cpu，出现了进程  ，线程，操作系统调度任务分配给进程时间片，进程又包含无数个线程，进程也会调度线程，产生线程切换，任务切换就会导致原子性问题，比如 count++，在最终执行的cpu指令会分为三条
- 把变量从内存读到cpu寄存器
- 寄存器执行+1
- 结果写入内存(可能写入的是cpu缓存，不一定是内存)
所以会有可能在指令1或者指令2切换线程，导致出现count结果并不如自己想的那样
> cpu执行多个操作不可被中断称之为原子性，而原子操作的级别是cpu指令，而不是高级语言的操作符
而我们需要的正是在高级语言层面保证原子性
### 有序性
有序性指的是程序代码按照先后顺序执行，但是编译器会按照规则来优化我们的代码，提高性能，而有的时候优化过后的代码是会出现莫名其妙的bug的
比如这里的一个单例
```code
    public class Singleton {
      static Singleton instance;
      static Singleton getInstance(){
        if (instance == null) {
          synchronized(Singleton.class) {
            if (instance == null)
              instance = new Singleton();
            }
        }
        return instance;
      }
    }
```
[单例模式jvm重排带来的问题](/JAVA/singleton.md?id=jvmRearrangement)
#### 可见，原子，有序性简单总结
只要我们能够理解到这三种特性在并发编程中的原理，很多并发bug是可以轻松解决的
#### 为什么需要重排序
在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待，通过乱序执行的技术，处理器可以大大提高执行效率。
#### 32位机器long型变量进行操作会有并发隐患？
非volatile类型的long和double型变量是8字节64位的，32位机器读或写这个变量时得把变量分成两个32位操作，线程读了某个值的高32位，低32位可能已经被另一个线程修改。所以官方推荐最好把long/double 变量声明为volatile或是同步加锁synchronize以避免并发问题
## java内存模型解决并发问题
java内存模型提供了volatile，final和sync和happen-before规则来让开发者更好的解决并发问题，以及达到可限制编译器和处理器的一些会导致并发问题操作。
### volatile的作用
这块应该很多地方都有解释了，我们来引用百度百科上的一段话
> volatile是一个类型修饰符（type specifier）.volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。
  volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了
  
意思就是告诉编译器不使用cpu缓存，通知线程直接从内存读写，juc包下的工具类也大量用到了这个关键字，
本质上是在读写这个被修饰的变量时，在读写前后加上了一种内存屏障，内存屏障会触发内存的刷新操作
### final的作用
修饰类不可被继承，修饰方法不可被重写，修饰变量值不可更改(引用类型只是引用地址不变，实际堆中值可改变)，这样做的话可以通知编译器随意优化这些代码
### sync的作用
...这个可以延伸出锁的状态和升级降级的策略以及对象的监视器了，改天单独写一篇
### happens-before规则
1. 程序顺序性规则:前面的操作可见于后续的任意操作，可以保证单线程下的有序性
2. volatile变量规则:对一个volatile变量的写可见于后续的读操作，前面讲过了，加了内存屏障所以会刷新内存值
3. happens-before传递性规则: A happens-before于B,Bhappens-before于C,那么Ahappens-before于C
4. 管程锁规则:锁的解锁happens-before于后续的加锁(管程，比如sync就是管程的一种实现)
5. 线程start规则:主线程启动子线程前的操作happens-before于子线程
6. 线程join规则:主线程调用子线程join,阻塞完成后，子线程的所有操作happens-before于主线程
7. 程序中断规则:对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
8. 对象finalize规则:一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始
    
    

