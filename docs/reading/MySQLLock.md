## mysql中的锁的简单理解
### 事务并发带来的脏写问题
脏写:事务修改其他事务未提交的操作，在mysql四种隔离级别中都是不允许存在的
### 脏写解决方案
读事务共享，写操作的事务时，会先检查这条记录有没有关联的锁结构，一个简单的锁结构可以大致分为两个标志， 1.is_waiting当前记录是否有事务正在操作，2 trx_info 当前记录正在操作的事务信息，如果发现没有事务正在操作，则改变is_waiting为true，然后修改记录，最后把标志再改回false，同时唤醒其他想操作此记录的线程，如果发现事务的is_waiting为true就会阻塞，直到被唤醒。
### 脏读幻读和不可重复读
一般情况用mvcc来解决，特殊情况加锁解决
## 行锁和表锁
行锁可以分为s锁(读锁),x锁(写锁)，读读共享，读写互斥，写写互斥，表锁一般用不到,情况特殊才会用到，如DDL语句，表锁分为s锁，x锁，is锁，ix锁， is和ix其实是意向锁，因为锁表的时候需要判断表里有没有行锁，不可能遍历整表，所以事务在写行锁的时候，会先给表加上ix锁或者is锁，这样事务在锁表的时候就不用去遍历表里的记录，直接检查表有没有is或者ix锁就可以
## 补充行锁和表锁加锁方式
表锁一般DDL语句会表锁，日常开发中一般都是基于索引的行锁，也就是用到了哪个索引，就会根据哪个索引加锁，如果没有用到索引，会给所有行记录加锁，然后存储引擎返回给mysql的server，mysql通过过滤器再把不符合加锁条件的行给剔除掉， 在大批量修改的场景，没有用到索引的话，过滤器处理这些加锁的行会很耗时
## 行锁类型
1. record lock 
记录锁，也就是s锁和x锁
2. grap lock
间隙锁，会锁定加锁记录前一行记录到当前记录的区间，不允许变更，避免幻读，
3. next-key lock
等于记录锁+间隙锁
4. insert intent lock
插入意向锁，假如事务现在要插入被加了grap锁或者next-key锁的区间的话，会先加入插入意向锁的锁结构，然后处于等待状态，等待被唤醒
5. //todo  隐式锁